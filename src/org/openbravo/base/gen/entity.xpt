«IMPORT org::openbravo::base::model»
 
«EXTENSION org::openbravo::base::gen::gen_util» 
 
«DEFINE EntityTemplate FOR Entity»
	«FILE classFileName(this)-»
/*   
 *  
 * Copyright (C) 2001-2008 Openbravo S.L. Licensed under the Apache Software
 * License version 2.0 You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
 * or agreed to in writing, software distributed under the License is
 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
package «packageName»;

/** 
 * Entity class for entity «name» (stored in table «tableName»).
 *
 * NOTE: This class should not be instantiated directly. To instantiate this
 * class the OBFactory should be used. 
 */
public class «simpleClassName» extends org.openbravo.base.structure.BaseOBObject «implementsStatement» {

	public final static String TABLE_NAME = "«tableName»";
	public final static String ENTITY_NAME = "«name»";
	«FOREACH properties AS p-»
	public final static String PROPERTY_«((Property)p).name.toUpperCase()» = "«((Property)p).name»";
	«ENDFOREACH-»
	
	public «simpleClassName»() {
	«FOREACH properties AS p-»
		«IF ((Property)p).hasDefaultValue()-»
			setDefaultValue(PROPERTY_«((Property)p).name.toUpperCase()»,  «((Property)p).formattedDefaultValue»);
		«ENDIF-»
	«ENDFOREACH-»
	}
	
    @Override
	public String getEntityName() {
		return ENTITY_NAME;
	}
	
	«FOREACH properties AS p-»
	«IF !((Property)p).oneToMany»
	«IF ((Property)p).name.matches("Id") -»
    @Override
    «ENDIF-»
	public «((Property)p).typeName» «getter((Property)p)»() {
	«IF ((Property)p).partOfCompositeId-»
		return ((Id)getId()).«getter((Property)p)»();
	«ELSE-»
		return («((Property)p).typeName»)get(PROPERTY_«((Property)p).name.toUpperCase()»);
	«ENDIF-»
	}
	
	«IF ((Property)p).name.matches("Id") -»
    @Override
    «ENDIF-»
	public void set«((Property)p).getterSetterName.toFirstUpper()»(«((Property)p).typeName» «((Property)p).javaName») {
	«IF ((Property)p).partOfCompositeId-»
		((Id)getId()).set«((Property)p).getterSetterName.toFirstUpper()»(«((Property)p).javaName»);
	«ELSE-»
		set(PROPERTY_«((Property)p).name.toUpperCase()», «((Property)p).javaName»);
	«ENDIF-»
	}
	«ENDIF»
	«ENDFOREACH-»
	
	«FOREACH properties AS p-»
	«IF ((Property)p).oneToMany-»
	@SuppressWarnings("unchecked")
	public java.util.List<«((Property)p).targetEntity.className»> get«((Property)p).name.toFirstUpper()»() {
		return (java.util.List<«((Property)p).targetEntity.className»>) get(PROPERTY_«((Property)p).name.toUpperCase()»);
	}
	
	public void set«((Property)p).getterSetterName.toFirstUpper()»(java.util.List<«((Property)p).targetEntity.className»> «((Property)p).name») {
		set(PROPERTY_«((Property)p).name.toUpperCase()», «((Property)p).name»);
	}
	«ENDIF»
	«ENDFOREACH»

	«IF hasCompositeId()»
	public static class Id implements java.io.Serializable {
	    private static final long serialVersionUID = 1L;

		«FOREACH properties AS p-»
		«IF ((Property)p).partOfCompositeId-»
		«IF ((Property)p).hasDefaultValue()»
		private «((Property)p).typeName» «((Property)p).javaName» = «((Property)p).formattedDefaultValue»;
		«ELSE-»
		private «((Property)p).typeName» «((Property)p).javaName»;
		«ENDIF-»
		«ENDIF-»
		«ENDFOREACH-»

		«FOREACH properties AS p-»
		«IF ((Property)p).partOfCompositeId-»
		public «((Property)p).typeName» «getter((Property)p)»() {
			return «((Property)p).javaName»;
		}
		
		public void set«((Property)p).getterSetterName.toFirstUpper()»(«((Property)p).typeName» «((Property)p).javaName») {
			this.«((Property)p).javaName» = «((Property)p).javaName»;
		}
		«ENDIF»
		«ENDFOREACH-»
		
	    public boolean equals(Object obj) {
			if (this == obj) {
    			return true;
			}
			if (!(obj instanceof Id)) {
				return false;
			}
			final Id otherId = (Id)obj;
		«FOREACH properties AS p-»
		«IF ((Property)p).partOfCompositeId-»
			if (!areEqual(«getter((Property)p)»(), otherId.«getter((Property)p)»())) {
				return false;
			} 
		«ENDIF»
		«ENDFOREACH-»
			return true;
		}

		// hashCode assumes that keys can not change!
    	public int hashCode() {
    		int result = 0;
    		«FOREACH properties AS p-»
			«IF ((Property)p).partOfCompositeId-»
			if («getter((Property)p)»() instanceof Object) {
				result +=«getter((Property)p)»().hashCode(); 
			}
			«ENDIF-»
			«ENDFOREACH-»
    		
    		if (result == 0) {
    			return super.hashCode();
    		}
    		return result;
    	}

		private boolean areEqual(Object v1, Object v2) {
			if (v1 == null || v2 == null) {
				return v1 == v2;
			}
			return v1.equals(v2);
		}		
	}
	«ENDIF»
}
	«ENDFILE»
«ENDDEFINE»

# this define is there to get rid of the error
# displayed by the editor because for the 
# statement EXPAND Entity FOREACH model
# it can determine the type for model
«DEFINE EntityTemplate FOR Object»
«ENDDEFINE»
 