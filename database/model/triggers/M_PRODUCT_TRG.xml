<?xml version="1.0"?>
  <database name="TRIGGER M_PRODUCT_TRG">
    <trigger name="M_PRODUCT_TRG" table="M_PRODUCT" fires="after" insert="true" update="true" delete="true" foreach="row">
      <body><![CDATA[






    /*************************************************************************
    * The contents of this file are subject to the Openbravo  Public  License
    * Version  1.0  (the  "License"),  being   the  Mozilla   Public  License
    * Version 1.1  with a permitted attribution clause; you may not  use this
    * file except in compliance with the License. You  may  obtain  a copy of
    * the License at http://www.openbravo.com/legal/license.html
    * Software distributed under the License  is  distributed  on  an "AS IS"
    * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
    * License for the specific  language  governing  rights  and  limitations
    * under the License.
    * The Original Code is Openbravo ERP.
    * The Initial Developer of the Original Code is Openbravo SL
    * All portions are Copyright (C) 2001-2006 Openbravo SL
    * All Rights Reserved.
    * Contributor(s):  ______________________________________.
    ************************************************************************/

   TYPE RECORD IS REF CURSOR;
   Cur_Defaults RECORD;

    v_xTree_ID    NUMBER;
    v_xParent_ID  NUMBER;
    v_NextNo      NUMBER;
    v_ControlNo NUMBER;

BEGIN
 -- Do not allow to de-activate products with OnHand Qty
 IF (UPDATING) THEN
  IF (:new.IsActive='N' AND :old.IsActive='Y') THEN
         SELECT  COALESCE(SUM(QtyOnHand)+SUM(QtyReserved)*.111+SUM(QtyOrdered)*999, 0) INTO v_ControlNo
   FROM (SELECT QtyOnHand, 0 AS QtyReserved, 0 AS QtyOrdered
   FROM M_Storage_Detail s
   WHERE s.M_Product_ID=:new.M_Product_ID
   UNION
   SELECT 0 AS QtyOnHand, QtyReserved, QtyOrdered
   FROM M_Storage_Pending s
   WHERE s.M_Product_ID=:new.M_Product_ID) A;
   IF (v_ControlNo <> 0) THEN
    RAISE_APPLICATION_ERROR(-20400, 'Product has active Inventory');
   END IF;
  END IF;
  
  IF( COALESCE(:old.Name,'.') <> COALESCE(:new.Name,'.') 
  OR COALESCE(:old.documentnote,'.') <> COALESCE(:new.documentnote,'.') ) THEN
    UPDATE M_PRODUCT_Trl
      SET IsTranslated='N'
    WHERE M_PRODUCT_ID=:new.M_PRODUCT_ID;
  END IF;

  RETURN;
 ELSIF (INSERTING) THEN
  -- For all AcctSchema create ...
  FOR Cur_Defaults IN (SELECT  *
             FROM  M_Product_Category_Acct d
        WHERE  d.M_Product_Category_ID=:new.M_Product_Category_ID) LOOP
         --  Account
         INSERT INTO M_Product_Acct
             (M_Product_ID, C_AcctSchema_ID,
             AD_Client_ID, AD_Org_ID, IsActive, Created, CreatedBy, Updated, UpdatedBy,
             P_Revenue_Acct, P_Expense_Acct, P_Asset_Acct, P_COGS_Acct,
    P_PurchasePriceVariance_Acct, P_InvoicePriceVariance_Acct,
    P_TradeDiscountRec_Acct, P_TradeDiscountGrant_Acct)
         VALUES
             (:new.M_Product_ID, Cur_Defaults.C_AcctSchema_ID,
             :new.AD_Client_ID, :new.AD_ORG_ID, 'Y', now(), :new.CreatedBy, now(), :new.UpdatedBy,
             Cur_Defaults.P_Revenue_Acct, Cur_Defaults.P_Expense_Acct, Cur_Defaults.P_Asset_Acct, Cur_Defaults.P_COGS_Acct,
    Cur_Defaults.P_PurchasePriceVariance_Acct, Cur_Defaults.P_InvoicePriceVariance_Acct,
    Cur_Defaults.P_TradeDiscountRec_Acct, Cur_Defaults.P_TradeDiscountGrant_Acct);

   --  Costing
   INSERT INTO M_Product_Costing
    (M_Product_ID, C_AcctSchema_ID,
             AD_Client_ID, AD_Org_ID, IsActive, Created, CreatedBy, Updated, UpdatedBy,
    CurrentCostPrice, CostStandard, FutureCostPrice,
    CostStandardPOQty,CostStandardPOAmt,CostStandardCumQty,CostStandardCumAmt,
    CostAverage, CostAverageCumQty, CostAverageCumAmt,
    PriceLastPO, PriceLastInv,
    TotalInvQty, TotalInvAmt)
         VALUES
             (:new.M_Product_ID, Cur_Defaults.C_AcctSchema_ID,
             :new.AD_Client_ID, :new.AD_ORG_ID, 'Y', now(), :new.CreatedBy, now(), :new.UpdatedBy,
             0,0,0,  0,0,0,0,  0,0,0,  0,0,  0,0);
    END LOOP;


     --  Create Translation Row
     INSERT INTO M_Product_Trl
         (M_Product_ID, AD_Language, AD_Client_ID, AD_Org_ID,
         IsActive, Created, CreatedBy, Updated, UpdatedBy,
         Name, DocumentNote, IsTranslated)
     SELECT :new.M_Product_ID, AD_Language, :new.AD_Client_ID, :new.AD_Org_ID,
         :new.IsActive, :new.Created, :new.CreatedBy, :new.Updated, :new.UpdatedBy,
         :new.Name, :new.DocumentNote, 'N'
     FROM    AD_Language
     WHERE IsActive = 'Y' AND IsSystemLanguage = 'Y'
    AND EXISTS (SELECT * FROM AD_Client
     WHERE AD_Client_ID=:new.AD_Client_ID AND IsMultiLingualDocument='Y');


     --  Create TreeNode --
     --  get AD_Tree_ID + ParentID
     SELECT  c.AD_Tree_Product_ID, n.Node_ID INTO v_xTree_ID, v_xParent_ID
     FROM    AD_ClientInfo c, AD_TreeNodePR n
     WHERE   c.AD_Tree_Product_ID=n.AD_Tree_ID
         AND n.Parent_ID IS NULL
         AND c.AD_Client_ID=:new.AD_Client_ID;

     --  DBMS_OUTPUT.PUT_LINE('Tree='||v_xTree_ID||'  Node='||:new.M_Product_ID||'  Parent='||v_xParent_ID);

     --  Insert into TreeNode
     INSERT INTO AD_TreeNodePR
         (AD_Client_ID, AD_Org_ID,
         IsActive, Created, CreatedBy, Updated, UpdatedBy,
         AD_Tree_ID, Node_ID,
         Parent_ID, SeqNo)
     VALUES
         (:new.AD_Client_ID, :new.AD_Org_ID,
         :new.IsActive, :new.Created, :new.CreatedBy, :new.Updated, :new.UpdatedBy,
         v_xTree_ID, :new.M_Product_ID,
         v_xParent_ID, (CASE :new.IsSummary WHEN 'Y' THEN 100 ELSE 999 END));     -- Summary Nodes first
 ELSIF (DELETING) THEN
    DELETE FROM AD_TreeNodePR WHERE AD_Client_ID = :old.AD_Client_ID AND Node_ID = :old.M_Product_ID;
 END IF;
EXCEPTION
 WHEN NO_DATA_FOUND THEN
  RAISE_APPLICATION_ERROR(-20009, 'M_Product InsertTrigger Error: No ClientInfo or parent TreeNode');

END M_PRODUCT_TRG
]]></body>
    </trigger>
  </database>
